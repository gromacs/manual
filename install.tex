%
% 
%       This source code is part of
% 
%        G   R   O   M   A   C   S
% 
% GROningen MAchine for Chemical Simulations
% 
%               VERSION 2.0
% 
% Copyright (c) 1991-1999
% BIOSON Research Institute, Dept. of Biophysical Chemistry
% University of Groningen, The Netherlands
% 
% Please refer to:
% GROMACS: A message-passing parallel molecular dynamics implementation
% H.J.C. Berendsen, D. van der Spoel and R. van Drunen
% Comp. Phys. Comm. 91, 43-56 (1995)
% 
% Also check out our WWW page:
% http://md.chem.rug.nl/~gmx
% or e-mail to:
% gromacs@chem.rug.nl
% 
% And Hey:
% Gnomes, ROck Monsters And Chili Sauce
%

\chapter{Technical Details}
\label{ch:install}
\section{Installation}
The entire {\gromacs} package is Free Software, licensed under the GNU
Lesser General Public License; either version 2.1 of the License, or
(at your option) any later version.
The main distribution site is our WWW server at {\wwwpage}. 

The package is mainly distributed as source code, but others provide
packages for Linux and Mac. Check your Linux distribution tools
(search for gromacs). On Mac OS X the {\bf port} tool will allow you
to install a recent version.
On the home page you will find all the information you need to 
\normindex{install} the package, mailing lists with archives,
and several additional on-line resources like contributed topologies, etc.
%% The default installation action is simply to unpack the source code and
%% then issue:
%% \begin{verbatim}
%% ./configure
%% make
%% make install
%% \end{verbatim}
%% The configuration script should automatically determine the best options
%% for your platform, and it will tell you if anything is missing on
%% your system. You will also find detailed step-by-step installation
%% instructions on the website. There is a \normindex{cmake} based
%% installation route as well:
%% \begin{verbatim}
%% cmake
%% make
%% make install
%% \end{verbatim}
%% which is being tested in the wild since {\gromacs} version 4.5.

\section{Single or Double precision}
{\gromacs} can be compiled in either single\index{single
precision|see{precision, single}}\index{precision, single} or
\pawsindex{double}{precision}. It is very important to note here that
single precision is actually mixed precision. Using single precision
for all variables would lead to a significant reduction in accuracy.
Although in single precision all state vectors, i.e. particle coordinates,
velocities and forces, are stored in single precision, critical variables
are double precision. A typical example of the latter is the virial,
which is a sum over all forces in the system, which have varying signs.
In addition, in many parts of the code we managed to avoid double precision
for arithmetic, by paying attention to summation order or reorganization
of mathematical expressions. The default choice is single precision,
but it is easy to turn on double precision by adding the option
{\tt -DGMX_DOUBLE=on} to {\tt cmake}. Double precision
will be 20 to 100\% slower than single precision depending on the
architecture you are running on. Double precision will use somewhat
more memory and run input, energy and full-precision trajectory files
will be almost twice as large.  SIMD (single-instruction multiple-data)
intrinsics non-bonded force and/or energy kernels are available for x86
hardware in single and double precision in different SSE and AVX flavors;
the minimum requirement is SSE2.
IBM Blue Gene Q intrinsics will be available soon. Some other parts of
the code, especially PME, also employ x86 SIMD intrinsics. All other
hardware will use optimized C kernels. The Verlet non-bonded scheme
uses SIMD non-bonded kernels that are C pre-processor macro driven,
therefore it is straightforward to implement SIMD acceleration
for new architectures; a guide is provided on {\wwwpage}.

The energies in single precision are accurate up to the last decimal,
the last one or two decimals of the forces are non-significant.
The virial is less accurate than the forces, since the virial is only one
order of magnitude larger than the size of each element in the sum over
all atoms (\secref{virial}).
In most cases this is not really a problem, since the fluctuations in the
virial can be two orders of magnitude larger than the average.
Using cut-offs for the Coulomb interactions cause large errors
in the energies, forces, and virial.
Even when using a reaction-field or lattice sum method, the errors
are larger than, or comparable to, the errors due to the single precision.
Since MD is chaotic, trajectories with very similar starting conditions will
diverge rapidly, the divergence is faster in single precision than in double
precision.

For most simulations single precision is accurate enough.
In some cases double precision is required to get reasonable results:
\begin{itemize}
\item normal mode analysis,
for the conjugate gradient or l-bfgs minimization and the calculation and
diagonalization of the Hessian
\item long-term energy conservation, especially for large systems
\end{itemize}

\section{Porting {\gromacs}}
The {\gromacs} system is designed with portability as a major design
goal. However there are a number of things we assume to be present on
the system {\gromacs} is being ported on. We assume the following
features:

\begin{enumerate}
\item   A UNIX-like operating system (BSD 4.x or SYSTEM V rev.3 or higher) 
        or UNIX-like libraries running under {\eg} Cygwin
\item   an ANSI C compiler 
\end{enumerate}

There are some additional features in the package that require extra
stuff to be present, but it is checked for in the configuration script
and you will be warned if anything important is missing.

That's the requirements for a single node system. If you want
to compile {\gromacs} for running a single simulation across multiple nodes,
you also need an MPI library (Message-Passing Interface) to perform the 
parallel communication. This is always shipped with supercomputers, and
for workstations you can find links to free MPI implementations through
the {\gromacs} homepage at {\wwwpage}.


\section{Environment Variables}
{\gromacs} programs may be influenced by the use of
\normindex{environment variables}.  First of all, the variables set in
the {\tt \normindex{GMXRC}} file are essential for running and
compiling {\gromacs}. Some other useful environment variables are
listed in the following sections. Most environment variables function
by being set in your shell to any non-NULL value. Specific
requirements are described below if other values need to be set. You
should consult the documentation for your shell for instructions on
how to set environment variables in the current shell, or in config
files for future shells. Note that requirements for exporting
environment variables to jobs run under batch control systems vary and
you should consult your local documentation for details.

{\bf Output Control}

\begin{enumerate}

\item   {\tt GMX_CONSTRAINTVIR}: print constraint virial and force virial energy terms.
\item   {\tt GMX_MAXBACKUP}: {\gromacs} automatically backs up old
        copies of files when trying to write a new file of the same
        name, and this variable controls the maximum number of
        backups that will be made, default 99.
\item   {\tt GMX_NO_QUOTES}: if this is explicitly set, no cool quotes
        will be printed at the end of a program.
\item   {\tt GMX_SUPPRESS_DUMP}: prevent dumping of step files during
        (for example) blowing up during failure of constraint
        algorithms.
\item   {\tt GMX_TPI_DUMP}: dump all configurations to a {\tt .pdb}
        file that have an interaction energy less than the value set
        in this environment variable.
\item   {\tt GMX_VIEW_XPM}: {\tt GMX_VIEW_XVG}, {\tt
        GMX_VIEW_EPS} and {\tt GMX_VIEW_PDB}, commands used to
        automatically view \@ {\tt .xvg}, {\tt .xpm}, {\tt .eps}
        and {\tt .pdb} file types, respectively; they default to {\tt xv}, {\tt xmgrace},
        {\tt ghostview} and {\tt rasmol}. Set to empty to disable
        automatic viewing of a particular file type. The command will
        be forked off and run in the background at the same priority
        as the {\gromacs} tool (which might not be what you want).
        Be careful not to use a command which blocks the terminal
        ({\eg} {\tt vi}), since multiple instances might be run.
\item   {\tt GMX_VIRIAL_TEMPERATURE}: print virial temperature energy term
\item   {\tt LOG_BUFS}: the size of the buffer for file I/O. When set
        to 0, all file I/O will be unbuffered and therefore very slow.
        This can be handy for debugging purposes, because it ensures
        that all files are always totally up-to-date.
\item   {\tt LOGO}: set display color for logo in {\tt \normindex{ngmx}}.
\item   {\tt LONGFORMAT}: use long float format when printing
        decimal values.

\end{enumerate}


{\bf Debugging}

\begin{enumerate}

\item   {\tt DUMPNL}: dump neighbor list. 
        If set to a positive number the {\em entire}
        neighbor list is printed in the log file (may be many megabytes).
        Mainly for debugging purposes, but may also be handy for
        porting to other platforms.
\item   {\tt WHERE}: when set, print debugging info on line numbers.

% At this point, all environment variables should be described
%\item   There are a number of extra environment variables like these
%        that are used in debugging - check the code!

\end{enumerate}

{\bf Performance and Run Control}

\begin{enumerate}

\item   {\tt DISTGCT}: couple distances between two atoms when doing general coupling
        theory processes. The format is a string containing two integers, separated by a space.
\item   {\tt GALACTIC_DYNAMICS}: planetary simulations are made possible (just for fun) by setting
        this environment variable, which allows setting {\tt epsilon_r = -1} in the {\tt .mdp}
        file. Normally, {\tt epsilon_r} must be greater than zero to prevent a fatal error.
        See {\wwwpage} for example input files for a planetary simulation.
\item   {\tt GMX_ALLOW_CPT_MISMATCH}: when set, runs will not exit if the
        ensemble set in the {\tt .tpr} file does not match that of the
        {\tt .cpt} file.
\item   {\tt GMX_CAPACITY}: the maximum capacity of charge groups per
        processor when using particle decomposition.
% TODO document this
\item   {\tt GMX_CUDA_NB_DEFAULT}: mutually exclusive of {\tt GMX_CUDA_NB_LEGACY}.
% END TODO
\item   {\tt GMX_CUDA_NB_EWALD_TWINCUT}: force the use of twin-range cutoff scheme even if {\tt rvdw} =
        {\tt rcoulomb} initially. Used only for benchmarking.
% TODO document this
\item   {\tt GMX_CUDA_NB_LEGACY}: mutually exclusive of {\tt GMX_CUDA_NB_DEFAULT}.
% END TODO
\item   {\tt GMX_CUDA_STREAMSYNC}: force the use of cudaStreamSynchronized on ECC-enabled GPUs, which leads
        to performance loss due to a known CUDA driver bug. Cannot be set simultaneously with
        {\tt GMX_NO_CUDA_STREAMSYNC}.
\item   {\tt GMX_CYCLE_ALL}: times all code during runs.  Incompatible with threads.
\item   {\tt GMX_CYCLE_BARRIER}: calls MPI_Barrier before each cycle start/stop call.
\item   {\tt GMX_DD_ORDER_ZYX}: build domain decomposition cells in the order
        (z, y, x) rather than the default (x, y, z).
\item   {\tt GMX_DETAILED_PERF_STATS}: when set, print slightly more detailed performance information
        to the {\tt .log} file.
\item   {\tt GMX_DISABLE_CPU_ACCELERATION}: disables all architecture-specific (SSE2, SSE4, AVX, etc.)
        routines.
% TODO document this
\item   {\tt GMX_DISABLE_CUDA_TIMING}:
% END TODO
\item   {\tt GMX_DISABLE_GPU_DETECTION}: when set, disables GPU detection even if {\tt \normindex{mdrun}} was compiled
        with GPU support.
\item   {\tt GMX_DISABLE_PINHT}: disable pinning of consecutive threads to physical cores when using
        Intel hyperthreading.
\item   {\tt GMX_DISRE_ENSEMBLE_SIZE}: the number of systems for distance restraint ensemble
        averaging. Takes an integer value.
\item   {\tt GMX_EMULATE_GPU}: run GPU emulation on CPU hardware to get a performance estimate.  
        Automatically triggered if nonbonded calculations are turned off using {\tt GMX_NO_NONBONDED}.
\item   {\tt GMX_ENX_NO_FATAL}: disable exiting upon encountering a corrupted frame in an {\tt .edr}
        file, allowing the use of all frames up until the corruption.
\item   {\tt GMX_FORCE_UPDATE}: update forces when invoking {\tt \normindex{mdrun} -rerun}.
% TODO document these
\item   {\tt GMX_GPU_ALWAYS_ENER}:
\item   {\tt GMX_GPU_ALWAYS_PRUNE}:
% END TODO 
\item   {\tt GMX_GPU_ID}: set in the same way as the {\tt \normindex{mdrun}} option {\tt -gpu_id}, {\tt GMX_GPU_ID}
        allows the user to specify different GPU id's, which can be useful for selecting different
        cards on nodes in a cluster.  Cannot be used in conjunction with {\tt -gpu_id}.
% TODO document this one
\item   {\tt GMX_GPU_NEVER_ENER}:
% END TODO
\item   {\tt GMX_IGNORE_FSYNC_FAILURE_ENV}: allow {\tt \normindex{mdrun}} to continue even if
        a file is missing.
\item   {\tt GMX_LJCOMB_TOL}: when set to a floating-point value, overrides the default tolerance of
        1e-5 for force-field floating-point parameters.
\item   {\tt GMX_MAX_MPI_THREADS}: sets the maximum number of MPI-threads that {\tt \normindex{mdrun}}
        can use.
\item   {\tt GMX_MAXCONSTRWARN}: if set to -1, {\tt \normindex{mdrun}} will
        not exit if it produces too many LINCS warnings.
\item   {\tt GMX_NB_GENERIC}: use the generic C kernel.  Should be set if using
        the group-based cutoff scheme and also sets {\tt GMX_NO_SOLV_OPT} to be true,
        thus disabling solvent optimizations as well.
% TODO - this one could be better
\item   {\tt GMX_NB_MIN_CI}: neighbor list balancing parameter, used when running on GPU.  Must be set to
        a positive integer.
% END TODO
\item   {\tt GMX_NBLISTCG}: use neighbor list and kernels based on charge groups.
\item   {\tt GMX_NBNXN_CYCLE}: when set, print detailed neighbor search cycle counting.
% TODO document these
\item   {\tt GMX_NBNXN_EWALD_ANALYTICAL}:
\item   {\tt GMX_NBNXN_EWALD_TABLE}:
\item   {\tt GMX_NBNXN_SIMD_2XNN}:
\item   {\tt GMX_NBNXN_SIMD_4XN}:
% END TODO
\item   {\tt GMX_NO_ALLVSALL}: disables optimized all-vs-all kernels.
\item   {\tt GMX_NO_CART_REORDER}: used in initializing domain decomposition communicators. Node reordering
        is default, but can be switched off with this environment variable.
\item   {\tt GMX_NO_CUDA_STREAMSYNC}: the opposite of {\tt GMX_CUDA_STREAMSYNC}. Disables cudaStreamSynchronize
        to improve performance.
\item   {\tt GMX_NO_INT}, {\tt GMX_NO_TERM}, {\tt GMX_NO_USR1}: disable signal handlers for SIGINT,
        SIGTERM, and SIGUSR1, respectively.
\item   {\tt GMX_NO_NODECOMM}: do not use separate inter- and intra-node communicators.
\item   {\tt GMX_NO_PULLVIR}: when set, do not add virial contribution to COM pull forces.
\item   {\tt GMX_NOCHARGEGROUPS}: disables multi-atom charge groups, {\ie} each atom 
        in all non-solvent molecules is assigned its own charge group.
\item   {\tt GMX_NOPREDICT}: shell positions are not predicted.
\item   {\tt GMX_NO_SOLV_OPT}: turns off solvent optimizations; automatic if {\tt GMX_NB_GENERIC}
        is enabled.
\item   {\tt GMX_NSCELL_NCG}: the ideal number of charge groups per neighbor searching grid cell is hard-coded
        to a value of 10. Setting this environment variable to any other integer value overrides this hard-coded
        value.
\item   {\tt GMX_PME_NTHREADS}: set the number of OpenMP or PME threads (overrides the number guessed by 
        {\tt \normindex{mdrun}}.
\item   {\tt GMX_PME_P3M}: use P3M-optimized influence function instead of smooth PME B-spline interpolation.
\item   {\tt GMX_PME_THREAD_DIVISION}: PME thread division in the format ``x y z'' for all three dimensions. The
        sum of the threads in each dimension must equal the total number of PME threads (set in 
        {\tt GMX_PME_NTHREADS}).
\item   {\tt GMX_PMEONEDD}: if the number of domain decomposition cells is set to 1 for both x and y, 
        decompose PME in one dimension.
\item   {\tt GMX_REQUIRE_SHELL_INIT}: require that shell positions are initiated.
\item   {\tt GMX_REQUIRE_TABLES}: require the use of tabulated Coulombic
        and van der Waals interactions.
\item   {\tt GMX_SCSIGMA_MIN}: the minimum value for soft-core $\sigma$. {\bf Note} that this value is set
        using the {\tt sc-sigma} keyword in the {\tt .mdp} file, but this environment variable can be used
        to reproduce pre-4.5 behavior with respect to this parameter.
\item   {\tt GMX_TPIC_MASSES}: should contain multiple masses used for test particle insertion into a cavity.
        The center of mass of the last atoms is used for insertion into the cavity.
\item   {\tt GMX_USE_GRAPH}: use graph for bonded interactions.
\item   {\tt GMX_VERLET_BUFFER_RES}: resolution of buffer size in Verlet cutoff scheme.  The default value is
        0.001, but can be overridden with this environment variable.
\item   {\tt GMX_VERLET_SCHEME}: convert from group-based to Verlet cutoff scheme, even if the {\tt cutoff_scheme} is
        not set to use Verlet in the {\tt .mdp} file.
\item   {\tt GMXNPRI}: for SGI systems only. When set, gives the default non-degrading priority (npri) 
        for {\tt \normindex{mdrun}}, {\tt \normindex{g_covar}} and {\tt \normindex{g_nmeig}},
        {\eg} setting {\tt setenv GMXNPRI 250} causes all runs to be performed at near-lowest priority by default.
\item   {\tt GMXNPRIALL}: same as {\tt GMXNPRI}, but for all processes.
\item   {\tt GOMP_CPU_AFFINITY}: used to set GNU OpenMP thread affinity, which can conflict with internal thread
        affinity and lead to performance loss.  Also honored by Intel OpenMP implementation.
\item   {\tt KMP_AFFINITY}: same as {\tt GOMP_CPU_AFFINITY}, but specific to Intel.
\item   {\tt MPIRUN}: the {\tt mpirun} command used by {\tt \normindex{g_tune_pme}}.
\item   {\tt MDRUN}: the {\tt \normindex{mdrun}} command used by {\tt \normindex{g_tune_pme}}.
\item   {\tt NSTLIST_ENVVAR}: sets the default value for {\tt nstlist}, preventing it from being tuned during
        {\tt \normindex{mdrun}} startup when using the Verlet cutoff scheme.
\item   {\tt OMP_NUM_THREADS}: the number of OpenMP threads per process, if different from the maximum
        number of threads available.

\end{enumerate}

{\bf Analysis and Core Functions}

\begin{enumerate}

\item   {\tt ACC}: accuracy in Gaussian L510 (MC-SCF) component program.
\item   {\tt BASENAME}: prefix of {\tt .tpr} files, used in Orca calculations
        for input and output file names.
\item   {\tt CPMCSCF}: when set to a nonzero value, Gaussian QM calculations will
        iteratively solve the CP-MCSCF equations.
\item   {\tt DEVEL_DIR}: location of modified links in Gaussian.
\item   {\tt DSSP}: used by {\tt \normindex{do_dssp}} to point to the {\tt dssp}
        executable (not just its path).
\item   {\tt GAUSS_DIR}: directory where Gaussian is installed.
\item   {\tt GAUSS_EXE}: name of the Gaussian executable.
\item   {\tt GKRWIDTH}: spacing used by {\tt \normindex{g_dipoles}}.
\item   {\tt GMX_MAXRESRENUM}: sets the maximum number of residues to be renumbered by
        {\tt \normindex{grompp}}. A value of -1 indicates all residues should be renumbered.
\item   {\tt GMX_FFRTP_TER_RENAME}: Some force fields (like AMBER) use specific names for N- and C-
        terminal residues (NXXX and CXXX) as {\tt .rtp} entries that are normally renamed. Setting
        this environment variable disables this renaming.
\item   {\tt GMX_PATH_GZIP}: {\tt gunzip} executable, used by {\tt \normindex{g_wham}}.
\item   {\tt GMXFONT}: name of X11 font used by {\tt \normindex{ngmx}}.
\item   {\tt GMXTIMEUNIT}: the time unit used in output files, can be
        anything in fs, ps, ns, us, ms, s, m or h.
\item   {\tt MEM}: memory used for Gaussian QM calculation.
\item   {\tt MULTIPROT}: name of the {\tt multiprot} executable, used by the
        contributed program {\tt \normindex{do_multiprot}}.
\item   {\tt NCPUS}: number of CPUs to be used for Gaussian QM calculation
\item   {\tt OPENMM_PLUGIN_DIR}: the location of OpenMM plugins, needed for
        {\tt \normindex{mdrun-gpu}}.
\item   {\tt ORCA_PATH}: directory where Orca is installed.
\item   {\tt SASTEP}: simulated annealing step size for Gaussian QM calculation.
\item   {\tt STATE}: defines state for Gaussian surface hopping calculation.
\item   {\tt TESTMC}: perform 1000 random swaps in Monte Carlo clustering method
        within {\tt \normindex{g_cluster}}.
\item   {\tt TOTAL}: name of the {\tt total} executable used by the contributed
        {\tt \normindex{do_shift}} program.
\item   {\tt VERBOSE}: make {\tt \normindex{g_energy}} and {\tt \normindex{eneconv}}
        loud and noisy.
\item   {\tt VMD_PLUGIN_PATH}: where to find VMD plug-ins. Needed to be
        able to read file formats recognized only by a VMD plug-in.
\item   {\tt VMDDIR}: base path of VMD installation.
\item   {\tt XMGR}: sets viewer to {\tt xmgr} (deprecated) instead of {\tt xmgrace}.

\end{enumerate}

\section{Running {\gromacs} in parallel}
By default {\gromacs} will be compiled with the built-in threaded MPI library.
This library supports MPI communication between threads instead of between
processes. To run {\gromacs} in parallel over multiple nodes in a cluster
of a supercomputer, you need to configure and compile {\gromacs} with an external
MPI library. All supercomputers are shipped with MPI libraries optimized for 
that particular platform, and if you are using a cluster of workstations
there are several good free MPI implementations;
Open MPI is usually a good choice. Once you have an MPI library
installed it's trivial to compile {\gromacs} with MPI support: Just pass
the option {\tt -DGMX_MPI=on} to {\tt cmake} and (re-)compile. Please see
the {\gromacs} webpage for more detailed instructions.
Note that in addition to MPI parallelization, {\gromacs} supports
thread-parallelization through \normindex{OpenMP}. MPI and OpenMP parallelization
can be combined, which results in, so called, hybrid parallelization.
See {\wwwpage} for details on use and performance of the parallelization
schemes.

For communications over multiple nodes connected by a network,
there is a program usually called {\tt mpirun} with which you can start 
the parallel processes. A typical command line could look like:
{\tt mpirun -np 10 mdrun_mpi -s topol -v}

With the implementation of threading available by default in {\gromacs} version 4.5, 
if you have a single machine with multiple processors you don't have to
use the {\tt mpirun} command, or compile with MPI. Instead, you can allow GROMACS to determine the number of threads automatically, or use the {\tt mdrun} option {\tt -nt}:
{\tt mdrun -nt 8 -s topol.tpr}

Check your local manuals (or online manual) for exact details
of your MPI implementation.

If you are interested in programming MPI yourself, you can find
manuals and reference literature on the internet.



% LocalWords:  Opteron Itanium PowerPC Altivec Athlon Fortran virial bfgs Nasm
% LocalWords:  diagonalization Cygwin MPI Multi GMXHOME extern gmx tx pid buf
% LocalWords:  bufsize txs rx rxs init nprocs fp msg GMXRC DUMPNL BUFS GMXNPRI
% LocalWords:  unbuffered SGI npri mdrun covar nmeig setenv XPM XVG EPS
% LocalWords:  PDB xvg xpm eps pdb xmgrace ghostview rasmol GMXTIMEUNIT fs dssp
% LocalWords:  mpi distclean ing mpirun goofus doofus fred topol np
% LocalWords:  internet
